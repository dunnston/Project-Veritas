# PlayerController.gd Review

## Potential Bugs / Edge Cases
- Damage is reduced twice when routed through `take_damage()`. That method already runs the value through `AttributeManager.calculate_damage_reduction()` before delegating to `modify_health(-damage)`, and `modify_health()` then calls `EquipmentManager.calculate_damage_reduction()` again whenever the amount is negative. The double pass can trivialise incoming damage or even clamp it to the hard minimum of 1, regardless of the original attack strength. Consider returning raw damage from `take_damage()` and letting `modify_health()` apply a single reduction, or bypass the reduction path in `modify_health()` when the caller already processed mitigation. 【F:scripts/player/PlayerController.gd†L248-L255】【F:scripts/player/PlayerController.gd†L487-L541】
- `apply_survival_debuffs()` emits warning messages every physics frame once hunger or thirst reach zero. Without throttling or state tracking this will spam the UI/event bus and log, potentially tanking performance when stats remain depleted. Cache the last warning time or require the value to recover before re-emitting. 【F:scripts/player/PlayerController.gd†L170-L185】
- `interact_with_nearest()` assumes every entry in `nearby_interactables` is still a live node. If an interactable queues free while still inside the area, Godot can leave an invalid reference behind, causing `is_instance_valid()` assertions when you attempt to access properties. Filter the array for valid nodes (and optionally dedupe) before choosing the nearest target. 【F:scripts/player/PlayerController.gd†L210-L244】
- Speed modifiers are managed as an unordered stack: `remove_speed_modifier()` blindly pops the last entry, so effects expiring out of order will remove the wrong multiplier and leave stale modifiers behind. Track modifiers with identifiers (e.g. dictionaries keyed by source) or remove by value. 【F:scripts/player/PlayerController.gd†L564-L575】

## Readability / Maintainability
- `_ready()` manually looks up child nodes every time the scene instantiates and prints numerous debugging statements. Converting the lookups to `@onready` properties provides type safety and clearer intent, and the debug output should be gated behind a verbose flag or removed to keep logs clean. 【F:scripts/player/PlayerController.gd†L43-L90】
- The script mixes Inventory and InventorySystem responsibilities (local `inventory` node vs. global `InventorySystem.add_item`). Consolidating to a single inventory abstraction will simplify reasoning about item flow. 【F:scripts/player/PlayerController.gd†L85-L90】【F:scripts/player/PlayerController.gd†L361-L383】
- At ~650 lines the controller is doing input, attribute sync, consumable logic, status effects, XP routing, and environmental damage. Splitting these concerns into focused components (movement, survival stats, combat, etc.) will reduce cognitive load and make future changes safer. 【F:scripts/player/PlayerController.gd†L1-L648】

## Performance / Polish
- Repeatedly calling `has_node("/root/AttributeManager")` and `get_node()` inside `_physics_process`-driven methods allocates `NodePath`s and traverses the tree every frame. Cache the singleton references in `_ready()` (or rely on autoloads) to avoid per-frame lookups. 【F:scripts/player/PlayerController.gd†L120-L168】【F:scripts/player/PlayerController.gd†L276-L304】
- Dozens of unconditional `print()` statements in hot code paths (`_ready`, interaction checks, item consumption, damage handling) will flood stdout during gameplay. Swap to Godot's logging categories or wrap them in a debug flag to avoid IO overhead in production builds. 【F:scripts/player/PlayerController.gd†L43-L338】

## Suggested Improvements
- Extract a small helper to fetch singleton managers safely (e.g. `_get_attribute_manager()` returning a cached reference) to remove repetitive `has_node/get_node` blocks. This also centralises error handling when a dependency is missing. 【F:scripts/player/PlayerController.gd†L120-L168】【F:scripts/player/PlayerController.gd†L276-L304】
- Replace the raw array used for `nearby_interactables` with a custom struct that tracks enter timestamps and automatically cleans up invalid entries. That would also make implementing interaction priority rules (e.g. by type) easier. 【F:scripts/player/PlayerController.gd†L210-L244】
- Consider moving the consumable-effect tables (`consume_item`, `consume_healing_item`) into data assets (JSON/resources) to trim the script size and make balancing possible without touching code. 【F:scripts/player/PlayerController.gd†L385-L411】【F:scripts/player/PlayerController.gd†L596-L648】
